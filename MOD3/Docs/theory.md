# PWM Brightness Control via Potentiometer and UART Debugging on AVR128DA48

## Table of Contents

1. [Overview](#overview)
2. [Hardware](#hardware)
3. [MCU Modules Used](#mcu-modules-used)
4. [Theory and Implementation](#theory-and-implementation)
5. [Summary](#summary)

---

## 1. Overview

This application demonstrates how to:

* Read analog voltage from a potentiometer using the **ADC** module.
* Adjust brightness of an onboard LED using **PWM** signal generated by **TCA1**.
* Output debug values of ADC and PWM over **UART** to observe results in MPLAB Data Visualizer.

---

## 2. Hardware

* **MCU:** AVR128DA48 (Curiosity Nano)
* **Potentiometer Input:** PD0 (ADC Channel AIN0)
* **PWM Output:** PC6 (LED, Active Low)
* **UART TX:** PA0 (connected to CP2102 USB-UART module)

---

## 3. MCU Modules Used

| Module  | Function                       | Datasheet Reference       |
| ------- | ------------------------------ | ------------------------- |
| ADC0    | Analog input (10-bit)          | Chapter 31 - Section 31.5 |
| TCA1    | Timer for PWM generation       | Chapter 21 - Section 21.5 |
| USART0  | Serial communication (TX only) | Chapter 25 - Section 25.5.7 |
| GPIO    | Configure pin directions       | Chapter 17 - Section 17.5 |
| PORTMUX | Remap timer output to PC6      | Chapter 16 - Section 16.3.7 |

---

## 4. Theory and Implementation

### 4.1. ADC Configuration

* Use **VDD (5V)** as reference voltage.
* Select **channel AIN0 (PD0)** for analog input.
* Use 10-bit resolution: ADC result ranges from 0 to 1023.
* Use system clock divided by 16: 4MHz / 16 = 250kHz ADC clock.

**Why 10-bit ADC?**

* Allows fine-grained brightness adjustment (1024 levels)

**Code:**

```c
ADC0.CTRLA = ADC_RESSEL_10BIT_gc | ADC_ENABLE_bm;
ADC0.MUXPOS = ADC_MUXPOS_AIN0_gc;
```

### 4.2. PWM Configuration (TCA1)

* Route **TCA1 waveform output** to **PC6** using `PORTMUX.TCAROUTEA`.
* Use **Single Slope PWM** mode: compare value (CMP2) defines duty cycle.
* Set PWM period to 255 (8-bit range).
* Set initial duty cycle to 0 (LED OFF).

**PWM value calculation:**

```c
uint8_t pwm_value = 255 - (adc_value >> 2);
```

* ADC value (0-1023) is scaled down to 0-255 using right shift by 2.
* Inverted so higher ADC input = lower PWM = higher brightness (active low LED).

### 4.3. UART Configuration (USART0)

* Transmit only (TX) to output data to Data Visualizer.
* Baud rate = 9600 bps, calculated using formula from datasheet.
* TX pin = PA0.

**Code:**

```c
USART0.BAUD = (F_CPU * 64 / (16 * BAUD_RATE)) + 0.5;
USART0.CTRLB = USART_TXEN_bm;
```

### 4.4. Main Loop Operation

1. Read potentiometer voltage via ADC.
2. Scale and invert ADC value to calculate PWM duty cycle.
3. Update PWM output to LED.
4. Send both ADC and PWM values over UART for plotting.
5. Add 50ms delay for stability.

```c
while (1) {
    uint16_t adc_value = ADC0_read();
    uint8_t pwm_value = 255 - (adc_value >> 2);
    TCA1.SINGLE.CMP2 = pwm_value;

    USART0_sendInt(adc_value);
    USART0_sendChar(',');
    USART0_sendInt(255 - pwm_value);
    USART0_sendChar('\n');

    _delay_ms(50);
}
```

**UART Output Format:**

```
ADC,PWM
1023,255
512,128
256,64
...
0,0
```

Use MPLAB Data Visualizer to monitor real-time graph.

---

## 5. Summary

| Module  | Purpose                    | Key Setting / Formula       |
| ------- | -------------------------- | --------------------------- |
| ADC0    | Read potentiometer         | 10-bit, channel AIN0        |
| TCA1    | Generate PWM to LED        | CMP2, WGMODE = SINGLE SLOPE |
| USART0  | Output values via UART     | Baud = 9600                 |
| PORTMUX | Route TCA1 output to PC6   | PORTMUX\_TCA1\_PORTC\_gc    |
| GPIO    | Set TX (PA0) and LED (PC6) | DIRSET, OUT registers       |

This task shows how analog input, PWM output, and UART debug can be combined to implement a real-time adjustable LED brightness system.
